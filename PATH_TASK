Guess open ports
================
import random

def port_checker(start_port, end_port):
    open_port = []
    for user_range in range(start_port, end_port):
        port = user_range
        computer_guess = random.randint(0,7)
        user_checker = port % 2
        if user_checker == computer_guess:
            open_port.append(port)
    return open_port        
start_port = int(input('start port:'))
end_port   = int(input('endport:'))    
port_check_caller = port_checker(start_port, end_port)
print('open ports' , port_check_caller)

Password Manager
================
import pickle
import sys

while True:
    password_man = {
        'x': {
                'username':'kay',
                'password':'pass'
                        },
        'facebook':{
                'username': 'jay',
                'password': '1234'
                        },
                }
    check = input ('enter the website or q for quit: ')
    if check in password_man:
        print('website:',(check),'\nusername:',password_man[check]['username'],'\npassword:',password_man[check]['password'])
    elif check == 'exit':
        print('bye')
        sys.exit()
    else:
        print('"there is no stored password for this website. \n would you like to store the username and password as new entry to the password manager for this website"')
        YN = input('Y/N: ')
        if (YN == 'Y') or (YN == 'y'):
            user = input('enter username: ')
            pas = input('password: ')
            password_man [(check)] = {'username':user, 'password':pas}
            print('successfully stored', password_man[(check)], 'for ' , check)
            
            file_path = "my_data.pkl"
            
            with open(file_path, 'wb') as f:
                pickle.dump(password_man, f)

                print(f"Dictionary saved to {file_path}")
        else:
            final = input('would you like to do an another entry: y/n> ')
            if final == 'N' or 'n':
                sys.exit()
            else:
                break

Access account with tuple()
---------------------------
access = {
    ('john', 'pass123'): 'account_info',
    ('mary', 'pass456'): 'other_info'
}
user = input ('username:')
passw = input ('pass:')
access[(user,passw)]
print(access[(user, passw)])


Weekend task 1:
================
import random
import pickle

stat = {
    'attempt' : 0,
    'win' : 0,
    'lose' : 0
}

def uservalue():
    try:
        number = int(input('enter a number:'))
        return number
    except ValueError:
        print('try a number')
    except:
        sys.exit()

def validate():
    sysinp = random.randint(1,10)
    left = []
    for i in range(0,5):
        userinp = uservalue()
        left.append(i)
        len_left = 5 - len(left)
        print(len_left, 'chance left')
        if (sysinp==userinp):
            print('correct')
            return True
    return False

def store(val):
    print(val)  
    if val == True:
        stat['attempt'] = stat['attempt']+1
        stat['win'] = stat ['win'] + 1
    else:
        stat['attempt'] = stat['attempt']+1
        stat['lose'] = stat['lose']+1
        
def save(stat):
    
        file_path = "my_datas.pkl"
        with open(file_path, 'wb') as f:
            pickle.dump(stat, f)
            print(f"Dictionary saved to {file_path}")

while True:
    try:
        val = validate()
        result = store(val)
        print(stat)
        print('hel')
        save(stat)
    except:
        ('while error, check root')
    
Strings
=======
stage 1 - Custom encoder (1-25)
-------------------------------

print('select function \n1.Encode\n2.Decode\n3.Both')
choice = int(input())
shift = int(input('enter a shift number (1-25)'))
text = input ('enter value:')

def encoder(text,shift):
    result = ''
    for char in text:
        if char.isalpha():
        
            if char.islower():
                inp_ord = (ord(char))
                pos =  inp_ord - 97
                k = (pos + shift) % 26
                out = chr(k + 97)
                result += out
            
            elif char.isupper():
                inp_ord = (ord(char))
                pos =  inp_ord - 65
                k = (pos + shift) % 26
                out = chr(k + 65)
                result += out
        else:
            result += char
    return result
    
def decoder(text,shift):
    result = ''
    for char in text:
        if char.isalpha():
            if char.islower():
                inp_ord = (ord(char))
                pos =  inp_ord - 97
                k = (pos - shift) % 26
                out = chr(k + 97)
                result += out
            elif char.isupper():
                inp_ord = (ord(char))
                pos =  inp_ord - 65
                k = (pos - shift) % 26
                out = chr(k + 65)
                result += out
        else:
            result += char
    return result 
    
if choice == 1:
    result = encoder(text,shift)
    print(result)
elif choice == 2:
    result = decoder(text,shift)
    print(result)
elif choice == 3:
    result_en = encoder(text,shift)
    result_de = decoder(result_en,shift)
    print('encoded result:',result_en)
    print('decoded result:',result_de)


Stage 2 - Base 64
-----------------

import base64

def encoder(cmd):
    utf = cmd.encode('utf-8')
    be = base64.b64encode(utf)
    re_val = be.decode('utf-8')
    return re_val

def decoder(cmd):
    utf = cmd.encode('utf-8')
    bd = base64.b64decode(utf)
    re_val = bd.decode('utf-8')
    return re_val


while True:
    try:
        print('1.Encode\n2.Decode\n3.Both')
        choice = int(input('Choice:'))
        if choice == 1:
            cmd = input('enter your input:')
            encd = encoder(cmd)
            print('Encoded value is:',encd)
            
        elif choice == 2:
            cmd = input('enter your input:')
            dccd = decoder(cmd)
            print('Decoded value is:',dccd)
            
        elif choice == 3:
            e_cmd = input('enter your input:')
            encd = encoder(e_cmd)
            dccd = decoder(encd)
            print('Encoded value is:',encd)
            print('Decoded value is:',dccd)

        else:
            print('you can try only by 1,2, or  3')
    except:
        print('you can try only by 1,2, or  3')
    
B2 detection - Check Base64 or not 
#---------------------------------#

import re
import base64
p = "^[A-Za-z0-9+/=]*$" # pattern
while True:
    text = input('enter input:')
    leng = len(text)
    val = bool(re.match(p,text))
    if leng % 4 == 0 and (val == True):
        print(text,'is base64')
    else:
        print(text, 'is not base64')

Base64 - Simple obfuscation (replace a, c, v)
---------------------------------------------
import base64

def encoder(cmd):
    utf = cmd.encode('utf-8')
    be = base64.b64encode(utf)
    re_val = be.decode('utf-8')
    if 'a' in re_val or 'c' in re_val or 'v' in re_val:
        replace = re_val.replace('a', '@').replace('c', '!').replace('v', '^')
        return replace
    else:
        return re_val

        
def decoder(cmd):
    if '@' in cmd or '!' in cmd or '^' in cmd:
        replace = cmd.replace('@', 'a').replace('!', 'c').replace('^', 'v')
        utf = replace.encode('utf-8')
        bd = base64.b64decode(utf)
        cmd = bd.decode('utf-8')
        return cmd
    else:
        utf = cmd.encode('utf-8')
        bd = base64.b64decode(utf)
        cmd = bd.decode('utf-8')
        return cmd

while True:
    cmd = input('enter your input:')
    encd = encoder(cmd)
    print('Encoded and replaced value is:',encd)
    decd = decoder(encd)
    print('decoded value is ',decd)


Double layered encoding (base64 and caesar)
-------------------------------------------
import base64

def encoder(shift, text):
    result = ''
    for char in text:
        if char.isalpha():        
            if char.islower():
                inp_ord = (ord(char))
                pos =  inp_ord - 97
                k = (pos + shift) % 26
                out = chr(k + 97)
                result += out
            elif char.isupper():
                inp_ord = (ord(char))
                pos =  inp_ord - 65
                k = (pos + shift) % 26
                out = chr(k + 65)
                result += out
        else:
            result += char
    utf = result.encode('utf-8')
    be = base64.b64encode(utf)
    re_val = be.decode('utf-8')
    return re_val
    
def decoder(text,shift):
    utf = text.encode('utf-8')
    bd = base64.b64decode(utf)
    re_val = bd.decode('utf-8')
    result = ''
    for char in re_val:
        if char.isalpha():
            if char.islower():
                inp_ord = (ord(char))
                pos =  inp_ord - 97
                k = (pos - shift) % 26
                out = chr(k + 97)
                result += out
            elif char.isupper():
                inp_ord = (ord(char))
                pos =  inp_ord - 65
                k = (pos - shift) % 26
                out = chr(k + 65)
                result += out
        else:
            result += char
    return result 

while True:
    shift = int(input('enter shift count:'))
    text = input('enter your input:')
    encd = encoder(shift, text)
    print('Encoded value is:',encd)
    decd = decoder(encd, shift)
    print('decoded value', decd)

XOR AND Base64 - encryption by XOR and encoding base64
------------------------------------------------------
import base64

def encoder(key, text):
    xor_bytes = bytes([ord(char) ^ key for char in text])
    enc = base64.b64encode(xor_bytes)
    utf = enc.decode('utf-8')
    return utf
    
def decoder(key, encd):
    dec = base64.b64decode(encd)
    print(dec)
    xor_bytes = ''.join([chr(byte ^ key) for byte in dec])
    return xor_bytes

while True:
    text = input('input:')
    key = int(input('key length:'))
    encd = encoder(key, text)
    decd = decoder(key, encd)
    print('encrypted xor with base 64 encode:', encd)
    print('decrypted xor and base64:',decd)

strings to hex() encoding
-------------------------

def encoder(text):
    encd = text.encode().hex()
    return encd
def decoder(text):
    decd = bytes.fromhex(text)
    plain = decd.decode('utf-8')
    return plain

while True:
    print('choice\n1.Encode\n2.Decode\n3.both')
    choice = int(input(':'))
    text = input('text:')
    if choice == 1:
        encd = encoder(text)
        print('hex encoded value is: ',encd)
    elif choice == 2:
        plain = decoder(text)
        print('hex decoded value is: ',plain)
    elif choice == 3:
        encd = encoder(text)
        plain = decoder(encd)
        print('hex encoded value is: ',encd)
        print('hex decoded value is: ',plain)

Multi-layared obfuscation
-------------------------
import base64, sys

def multi_layer_obfuscate(text):
    """Apply multiple obfuscation layers like real malware"""
    print('\n--- Applying Obfuscation Layers ---')

    # Layer 1: Reverse string
    layer1 = text[::-1]
    print(f'Layer 1 (Reversed): {layer1}')

    # Layer 2: Caesar cipher (shift 13 - ROT13)
    layer2 = ''
    for char in layer1:
        if char.isalpha():
            if char.islower():
                inp_ord = (ord(char))
                pos =  inp_ord - 97
                k = (pos + 13) % 26
                out = chr(k + 97)
                layer2 += out

            elif char.isupper():
                inp_ord = (ord(char))
                pos =  inp_ord - 65
                k = (pos + 13) % 26
                out = chr(k + 65)
                layer2 += out
        else:
            layer2 += char
    print(f'Layer 2 (Caesar): {layer2}')

    # layer 3: XOR encryption
    key = 25
    layer3 = bytes([ord(char) ^ key for char in layer2])
    print(f'Layer 3 (XOR): {layer3}')


    # Layer 4: Base64
    enc = layer3.decode('utf-8')
    utf = enc.encode('utf-8')
    be = base64.b64encode(utf)
    layer4 = be.decode('utf-8')
    print(f'Layer 4 (Base64): {layer4}')

    # Layer 5: Hex
    layer5 = layer4.encode().hex()
    print(f'Layer 5 (Hex): {layer5}')
    return layer5

def multi_layer_deobfuscate(obfuscated):
    """Remove all obfuscation layers in reverse order"""
    print('\n--- Removing Obfuscation Layers ---')

    # Reverse the order
    try:
        decd = bytes.fromhex(obfuscated)
        layer5 = decd.decode('utf-8')
        print(f'After Hex decode: {layer5}')
        
    except ValueError:
        print('enter a valide  value')
        return True
        
    #layer4 = base64_decoder(layer4)
    #utf = cmd.encode('utf-8')
    layer4 = base64.b64decode(layer5)
    #layer4 = bd.decode('utf-8')
    print(f'After Base64 decode: {layer4}')

    key = 25
    layer3 = ''.join([chr(byte ^ key) for byte in layer4])
    print(f'After XOR decryption: {layer3}')

    #layer1 = decoder(layer2)  # Use your Caesar decoder!

    layer2 = ''
    for char in layer3:
        if char.isalpha():
            if char.islower():
                inp_ord = (ord(char))
                pos =  inp_ord - 97
                k = (pos - 13) % 26
                out = chr(k + 97)
                layer2 += out
            elif char.isupper():
                inp_ord = (ord(char))
                pos =  inp_ord - 65
                k = (pos - 13) % 26
                out = chr(k + 65)
                layer2 += out
        else:
            layer2 += char
    print(f'After Caesar decode: {layer2}')

    #revers layer 1
    layer1 = layer2[::-1]  # Reverse the reversal
    print(f'reverse: {layer1}')
    return layer1
    
def run_choice(choice):
    
    if choice == 7:
        command = input('enter your command:')
        final = multi_layer_obfuscate(command)
        print(f'\nðŸ”’ FINAL OBFUSCATED: {final}')
        print('\nThis command is now heavily hidden!')

        while True:
            print('1.Main Menu\n0.Quit')
            select = int(input('option:'))
            if select == 0:
                sys.exit()           
            elif select == 0:
                print('enter a valid choice')
                continue
            else:
                break
            
    elif choice == 8:
        value = input('enter your value:')
        original = multi_layer_deobfuscate(value)
        print(f'\nðŸ”“ ORIGINAL COMMAND: {original}')
        
        while True:
            print('1.menu\n0.Quit')
            select = int(input('option:'))
            if select == 0:
                sys.exit()           
            elif select == 0:
                print('enter a valid choice')
                continue
            else:
                break
        
    elif choice == 9:
        command = input('enter your command:')
        final = multi_layer_obfuscate(command)
        print(f'\nðŸ”’ FINAL OBFUSCATED: {final}')
        print('\nThis command is now heavily hidden!')
        original = multi_layer_deobfuscate(final)
        print(f'\nðŸ”“ ORIGINAL COMMAND: {command}')
        while True:
            print('1.menu\n0.Quit')
            select = int(input('option:'))
            if select == 0:
                sys.exit()           
            elif select == 0:
                print('enter a valid choice')
                continue
            else:
                break

# Add to menu:
while True:
    print('\n7. Multi-Layer Obfuscate')
    print('8. Multi-Layer Deobfuscate')
    print('9. Multi-Layer Obfuscate and Deobfuscate')
    try:
        choice = int(input('choice:'))
        if choice == 7 or choice == 8 or choice == 9:
            call_choice_runner = run_choice(choice)
        else:
            print("Out of choice")
            continue
    except ValueError:
        print('enter a valid choice')
