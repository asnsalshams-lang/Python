Regex
=====
import re
num = 'my number is 90 897-760-1312'
pattern = re.compile(r'\d{3}-\d{3}-\d{4}') "creaete a regex pattern" | /d (decimal value 0-9)
match = pattern.search(num) "search matches from num"
result = match.group() "taking the result from num to a group"
print(k)

mulitple groups
----------------
text =  'my number is 90 897-760-1312'
pattern = re.compile(r'(\d\d) (\d\d\d)')
match = pattern.search(text)
group1 = match.group(1)
group2 = match.group(2)
print('group1:', group1)   #group1: 90
print('group2:', group2)   #group2: 897

groupig with parenthesis expression ()
--------------------------------------
text =  'my number is (901)897-760-1312'
pattern = re.compile(r'(\(\d\d\d\))(\d\d\d)')   "take a look at this pattern'(\(\d\d\d\)'"
match = pattern.search(text)
group1 = match.group(1)
group2 = match.group(2)
print('group1:', group1) #group1: (901)
print('group2:', group2) #group2: 897

match by by pipe | 
------------------
"will check the text contain any keywords from regex, but it will check multiple option like OR"
pattern = re.compile(r'he(lo|no|do)') "will flag if any keyword match he+lo or he+no or he+do"
match = pattern.search('edslfhelosdjflsd hel part hedoneeb lo (23)')
group = match.group()
print(group) #helo
print(match.group(1)) #lo "print which text is mathed with 'he'. in this example 'lo'"

Findall matches (findall())
---------------------------
text = 'Catch me if you can'
pattern = re.compile('helo|you|Catch')
match = pattern.findall(text)
print(match) #['Catch', 'you']

strings in tuple Goup
---------------------
text = 'Cell: 415 555 9999 Work: 212 555 0000'
pattern = re.compile('(\d{3}) (\d{3}) (\d{4})') will take 1st and 2nd numbers as reget match
match = pattern.findall(text)
print(match) #[('415', '555', '9999'), ('212', '555', '0000')]

No overlap
----------
pattern = re.compile(r'\d{3}')
match = pattern.findall('27364')
print(match) #273. 'only prints matched char'

pattern = re.compile(r'\d{3}')
match = pattern.findall('273640')
print(match) #['273', '640'] "will match 2 strings in a single group, it matches 3x2 char. 'findall()will print all results, group cannot do this function.'"

Match upper & lower
-------------------
text = 'Catch me, If you can'
pattern = re.compile('[catchmeiyouCatcme]') #will find the Upper and lower cahr as mentioned in this regex Pattern. eg: Catch me will take, because it Upper and lower already mentioned in tegex. but teh Find won't take the Upper. because the Upper 'I' didn't mention in regex/
match = pattern.findall(text)
print(match) #['C', 'a', 't', 'c', 'h', 'm', 'e', 'y', 'o', 'u', 'c', 'a'] "will take all char in single index"

Caret^ char for umatched char
-----------------------------
text = 'Catch me If you can'
pattern = re.compile('[^catchmeiyouCatcme]')
match = pattern.findall(text)
print(match) #[' ', ' ', 'I', 'f', ' ', ' ', 'n'] "will print the , as usual"

	

Shorthand character class AND Represents ...
--------------------------------------------

\d
Any numeric digit from 0 to 9.

\D
Any character that is not a numeric digit from 0 to 9.

\w
Any letter, numeric digit, or the underscore character. (Think of this as matching “word” characters.)

\W
Any character that is not a letter, numeric digit, or the underscore character.

\s
Any space, tab, or newline character. (Think of this as matching “space” characters.)

\S
Any character that is not a space, tab, or newline character.

Dec, Spaces, Letters, Underscore
--------------------------------
text = '12 -drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7swans, 6 geese,  rings, 4 birds, 3 hens, 2 doves, 1 partridge' 
pattern = re.compile(r'\d+\s\w+') "1.must 1 or more digits in starting, 2.must be a space afte digits, 3.must be a _ or dec or Letter."
match = pattern.findall(text)
print(match) #['11 pipers', '10 lords', '9 ladies', '8 maids', '6 geese', '4 birds', '3 hens', '2 doves', '1 partridge'] "won't give 12 -drummers, 7swans,   rings in result "

Matching by dot.
----------------
text = 'The cat is walking, Man is running'
pattern = re.compile(r'i.') "will check the i contain char, if match will take the i+next char eg:'is, in'"
match = pattern.findall(text)
print(match) #['is', 'in', 'is', 'in']

pattern = re.compile(r'.i') "will check the i contain char, if match will take the before+i char eg:' i,ki'"
#[' i', 'ki', ' i', 'ni']

pattern = re.compile(r'.i.') "will check the i contain char, if match will take the before+i+after char eg:' is,kin'"
#[' is', 'kin', ' is', 'nin']

Matching optional pattern
-------------------------
text = '42G!ew'
pattern = re.compile(r'42G!?')'!' is an optional
match = pattern.search(text)
print(match) #<re.Match object; span=(0, 4), match='42G!'>

text = '42Gew'
pattern = re.compile(r'42G!?') '!'is an optional
match = pattern.search(text)
print(match)#<re.Match object; span=(0, 3), match='42G'> 

text = '4!'
pattern = re.compile(r'42?!') "match the regesx to the text. 2 is optional. ! is mandatory"
match = pattern.search(text)
print(match)#4!

Optional in Group()
-------------------
text = '999-234-345-123'
text2 = '234-345-123'
pattern = re.compile(r'(\d{3}-)?\d{3}-\d{3}-\d{3}')
match = pattern.search(text)
print(match) #<re.Match object; span=(0, 15), match='999-234-345-123'>

match2 = pattern.search(text2)
print(match2) #<re.Match object; span=(0, 11), match='234-345-123'> "first group 999 is optional"

Matcing Zero or above by *
--------------------------
pattern = re.compile('Eggs( spam)*') "Eggs are must at one time no more. But spam is unlimitted 0-n because of the *"
matach2 = pattern.search('Eggs spam spam spam Eggs spam spam')
print(matach2) #<re.Match object; span=(0, 19), match='Eggs spam spam spam'>

Matchin 1 or above by +
-----------------------
pattern = re.compile('Eggs( spam)+')
matach = pattern.search('Eggs')
print(matach) #None "Because it must contain atleast one or more regex pattern match"

pattern = re.compile('Eggs( spam)+')
matach = pattern.search('Eggs spam')
print(matach) #<re.Match object; span=(0, 9), match='Eggs spam'> "Matched regex pattern"

Match one or more by {}
----------------------
pattern = re.compile('(Ha){3}')
matach = pattern.search('HaHaHaHa')
print(matach)#HaHaHa "will print HaHaHa not HaHaHaHa. and wont take pattern.search(HaHa). becuase 3 is fixed in regex"

pattern = re.compile('(Ha){3,}') "will print 3-n. not limit. but should be more than 3. its equals >=3"

pattern = re.compile('(Ha){,3}') "can print HaHaHa or HaHa or Ha. its equals to <=3"

pattern = re.compile('(Ha){3,5}') "Will take between 3-5 Ha, its like range"


